<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="testAllowExpressionInCube1">
    <Resource name="sql">
      <![CDATA[
SELECT MOD(deptno, 20) AS d, COUNT(*) AS c, gender AS g
FROM emp GROUP BY CUBE(MOD(deptno, 20), gender)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(d=[$0], c=[$2], g=[$1])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], c=[COUNT()])
   +- LogicalProject(d=[MOD($1, 20)], g=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[d, c, g])
+- HashAggregate(isMerge=[true], groupBy=[d, g, $e], select=[d, g, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[d, g, $e]])
      +- LocalHashAggregate(groupBy=[d, g, $e], select=[d, g, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{d=[$0], g=[$1], $e=[0]}, {d=[$0], g=[null], $e=[1]}, {d=[null], g=[$1], $e=[2]}, {d=[null], g=[null], $e=[3]}], projects=[{d, g, 0 AS $e}, {d, null AS g, 1 AS $e}, {null AS d, g, 2 AS $e}, {null AS d, null AS g, 3 AS $e}])
            +- Calc(select=[MOD(deptno, 20) AS d, gender AS g])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAllowExpressionInCube2">
    <Resource name="sql">
      <![CDATA[SELECT COUNT(*) AS c FROM emp GROUP BY CUBE(1)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$1])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
   +- LogicalProject($f0=[1])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c])
+- HashAggregate(isMerge=[true], groupBy=[$f0, $e], select=[$f0, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[$f0, $e]])
      +- LocalHashAggregate(groupBy=[$f0, $e], select=[$f0, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{$f0=[$0], $e=[0]}, {$f0=[null], $e=[1]}], projects=[{$f0, 0 AS $e}, {null AS $f0, 1 AS $e}])
            +- Calc(select=[1 AS $f0])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAllowExpressionInRollup1">
    <Resource name="sql">
      <![CDATA[
SELECT deptno + 1 AS d1, deptno + 1 - 1 AS d0, COUNT(*) AS c
FROM emp GROUP BY ROLLUP (deptno + 1)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(d1=[$0], d0=[-($0, 1)], c=[$1])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
   +- LogicalProject(d1=[+($1, 1)])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[d1, -(d1, 1) AS d0, c])
+- HashAggregate(isMerge=[true], groupBy=[d1, $e], select=[d1, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[d1, $e]])
      +- LocalHashAggregate(groupBy=[d1, $e], select=[d1, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{d1=[$0], $e=[0]}, {d1=[null], $e=[1]}], projects=[{d1, 0 AS $e}, {null AS d1, 1 AS $e}])
            +- Calc(select=[+(deptno, 1) AS d1])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAllowExpressionInRollup2">
    <Resource name="sql">
      <![CDATA[
select MOD(deptno, 20) AS d, COUNT(*) AS c, gender AS g
FROM emp GROUP BY ROLLUP(MOD(deptno, 20), gender)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(d=[$0], c=[$2], g=[$1])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], c=[COUNT()])
   +- LogicalProject(d=[MOD($1, 20)], g=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[d, c, g])
+- HashAggregate(isMerge=[true], groupBy=[d, g, $e], select=[d, g, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[d, g, $e]])
      +- LocalHashAggregate(groupBy=[d, g, $e], select=[d, g, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{d=[$0], g=[$1], $e=[0]}, {d=[$0], g=[null], $e=[1]}, {d=[null], g=[null], $e=[3]}], projects=[{d, g, 0 AS $e}, {d, null AS g, 1 AS $e}, {null AS d, null AS g, 3 AS $e}])
            +- Calc(select=[MOD(deptno, 20) AS d, gender AS g])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAllowExpressionInRollup3">
    <Resource name="sql">
      <![CDATA[SELECT COUNT(*) AS c FROM emp GROUP BY ROLLUP(1)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$1])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
   +- LogicalProject($f0=[1])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c])
+- HashAggregate(isMerge=[true], groupBy=[$f0, $e], select=[$f0, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[$f0, $e]])
      +- LocalHashAggregate(groupBy=[$f0, $e], select=[$f0, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{$f0=[$0], $e=[0]}, {$f0=[null], $e=[1]}], projects=[{$f0, 0 AS $e}, {null AS $f0, 1 AS $e}])
            +- Calc(select=[1 AS $f0])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testBasicGroupingSets">
    <Resource name="sql">
      <![CDATA[SELECT deptno, COUNT(*) AS c FROM emps GROUP BY GROUPING SETS ((), (deptno))]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
+- LogicalProject(deptno=[$2])
   +- LogicalTableScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, $e]])
      +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
            +- Calc(select=[deptno])
               +- TableSourceScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]], fields=[empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testCALCITE1824">
    <Resource name="sql">
      <![CDATA[
SELECT deptno, GROUP_ID() AS g, COUNT(*) AS c
FROM scott_emp GROUP BY GROUPING SETS (deptno, (), ())
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}], groups=[[{0}, {}]], g=[GROUP_ID()], c=[COUNT()])
+- LogicalProject(deptno=[$7])
   +- LogicalTableScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, 0:BIGINT AS g, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, $e]])
      +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
            +- Calc(select=[deptno])
               +- TableSourceScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]], fields=[empno, ename, job, mgr, hiredate, sal, comm, deptno])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testCube">
    <Resource name="sql">
      <![CDATA[
SELECT b, c,
    AVG(a) AS a,
    GROUP_ID() AS g,
    GROUPING(b) AS gb,
    GROUPING(c) AS gc,
    GROUPING_ID(b) AS gib,
    GROUPING_ID(c) AS gic,
    GROUPING_ID(b, c) AS gid
FROM MyTable
    GROUP BY CUBE (b, c)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], a=[AVG($2)], g=[GROUP_ID()], gb=[GROUPING($0)], gc=[GROUPING($1)], gib=[GROUPING_ID($0)], gic=[GROUPING_ID($1)], gid=[GROUPING_ID($0, $1)])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gb, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gc, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gib, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gic, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 2:BIGINT, 3:BIGINT) AS gid])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[$2], $e=[0]}, {a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[$2], $e=[2]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, c, 0 AS $e}, {a, b, null AS c, 1 AS $e}, {a, null AS b, c, 2 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testCubeAndDistinct">
    <Resource name="sql">
      <![CDATA[SELECT DISTINCT COUNT(*) FROM emp GROUP BY CUBE(deptno, gender)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}])
+- LogicalProject(EXPR$0=[$2])
   +- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], EXPR$0=[COUNT()])
      +- LogicalProject(deptno=[$1], gender=[$2])
         +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
HashAggregate(isMerge=[true], groupBy=[EXPR$0], select=[EXPR$0])
+- Exchange(distribution=[hash[EXPR$0]])
   +- LocalHashAggregate(groupBy=[EXPR$0], select=[EXPR$0])
      +- Calc(select=[EXPR$0])
         +- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS EXPR$0])
            +- Exchange(distribution=[hash[deptno, gender, $e]])
               +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
                  +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[$1], $e=[2]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, gender, 2 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
                     +- Calc(select=[deptno, gender])
                        +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testCubeAndJoin">
    <Resource name="sql">
      <![CDATA[
SELECT e.deptno, e.gender,
    MIN(e.ename) AS min_name
FROM emp AS e JOIN dept AS d USING (deptno)
    GROUP BY CUBE(e.deptno, d.deptno, e.gender)
    HAVING COUNT(*) > 2 OR gender = 'M' AND e.deptno = 10
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(deptno=[$0], gender=[$2], min_name=[$3])
+- LogicalFilter(condition=[OR(>($4, 2), AND(=($2, _UTF-16LE'M'), =($0, 10)))])
   +- LogicalAggregate(group=[{0, 1, 2}], groups=[[{0, 1, 2}, {0, 1}, {0, 2}, {0}, {1, 2}, {1}, {2}, {}]], min_name=[MIN($3)], agg#1=[COUNT()])
      +- LogicalProject(deptno=[$1], deptno0=[$3], gender=[$2], ename=[$0])
         +- LogicalJoin(condition=[=($1, $3)], joinType=[inner])
            :- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
            +- LogicalTableScan(table=[[default_catalog, default_database, dept, source: [TestTableSource(deptno, dname)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, gender, min_name], where=[OR(>($f5, 2), AND(=(gender, _UTF-16LE'M':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"), =(deptno, 10)))])
+- SortAggregate(isMerge=[true], groupBy=[deptno, gender, deptno0, $e], select=[deptno, gender, deptno0, $e, Final_MIN(min$0) AS min_name, Final_COUNT(count1$1) AS $f5])
   +- Sort(orderBy=[deptno ASC, gender ASC, deptno0 ASC, $e ASC])
      +- Exchange(distribution=[hash[deptno, gender, deptno0, $e]])
         +- LocalSortAggregate(groupBy=[deptno, gender, deptno0, $e], select=[deptno, gender, deptno0, $e, Partial_MIN(ename) AS min$0, Partial_COUNT(*) AS count1$1])
            +- Sort(orderBy=[deptno ASC, gender ASC, deptno0 ASC, $e ASC])
               +- Expand(projects=[{ename=[$0], deptno=[$1], gender=[$2], deptno0=[$3], $e=[0]}, {ename=[$0], deptno=[$1], gender=[$2], deptno0=[null], $e=[1]}, {ename=[$0], deptno=[$1], gender=[null], deptno0=[$3], $e=[2]}, {ename=[$0], deptno=[$1], gender=[null], deptno0=[null], $e=[3]}, {ename=[$0], deptno=[null], gender=[$2], deptno0=[$3], $e=[4]}, {ename=[$0], deptno=[null], gender=[$2], deptno0=[null], $e=[5]}, {ename=[$0], deptno=[null], gender=[null], deptno0=[$3], $e=[6]}, {ename=[$0], deptno=[null], gender=[null], deptno0=[null], $e=[7]}], projects=[{ename, deptno, gender, deptno0, 0 AS $e}, {ename, deptno, gender, null AS deptno0, 1 AS $e}, {ename, deptno, null AS gender, deptno0, 2 AS $e}, {ename, deptno, null AS gender, null AS deptno0, 3 AS $e}, {ename, null AS deptno, gender, deptno0, 4 AS $e}, {ename, null AS deptno, gender, null AS deptno0, 5 AS $e}, {ename, null AS deptno, null AS gender, deptno0, 6 AS $e}, {ename, null AS deptno, null AS gender, null AS deptno0, 7 AS $e}])
                  +- HashJoin(joinType=[InnerJoin], where=[=(deptno, deptno0)], select=[ename, deptno, gender, deptno0], build=[right])
                     :- Exchange(distribution=[hash[deptno]])
                     :  +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
                     +- Exchange(distribution=[hash[deptno]])
                        +- Calc(select=[deptno])
                           +- TableSourceScan(table=[[default_catalog, default_database, dept, source: [TestTableSource(deptno, dname)]]], fields=[deptno, dname])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testCubeAsGroupingSets">
    <Resource name="sql">
      <![CDATA[
SELECT b, c,
    AVG(a) AS a,
    GROUP_ID() AS g,
    GROUPING(b) AS gb,
    GROUPING(c) AS gc,
    GROUPING_ID(b) AS gib,
    GROUPING_ID(c) as gic,
    GROUPING_ID(b, c) AS gid
FROM MyTable
    GROUP BY CUBE (b, c)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], a=[AVG($2)], g=[GROUP_ID()], gb=[GROUPING($0)], gc=[GROUPING($1)], gib=[GROUPING_ID($0)], gic=[GROUPING_ID($1)], gid=[GROUPING_ID($0, $1)])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gb, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gc, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gib, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gic, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 2:BIGINT, 3:BIGINT) AS gid])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[$2], $e=[0]}, {a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[$2], $e=[2]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, c, 0 AS $e}, {a, b, null AS c, 1 AS $e}, {a, null AS b, c, 2 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testDuplicateArgumentToGrouping_id">
    <Resource name="sql">
      <![CDATA[
SELECT deptno, gender,
    GROUPING_ID(deptno, gender, deptno),
    COUNT(*) AS c
FROM emp WHERE deptno = 10
    GROUP BY ROLLUP(gender, deptno)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(deptno=[$1], gender=[$0], EXPR$2=[$2], c=[$3])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], EXPR$2=[GROUPING_ID($1, $0, $1)], c=[COUNT()])
   +- LogicalProject(gender=[$2], deptno=[$1])
      +- LogicalFilter(condition=[=($1, 10)])
         +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, gender, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 5:BIGINT, 7:BIGINT) AS EXPR$2, c])
+- HashAggregate(isMerge=[true], groupBy=[gender, deptno, $e], select=[gender, deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[gender, deptno, $e]])
      +- LocalHashAggregate(groupBy=[gender, deptno, $e], select=[gender, deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{gender=[$0], deptno=[$1], $e=[0]}, {gender=[$0], deptno=[null], $e=[1]}, {gender=[null], deptno=[null], $e=[3]}], projects=[{gender, deptno, 0 AS $e}, {gender, null AS deptno, 1 AS $e}, {null AS gender, null AS deptno, 3 AS $e}])
            +- Calc(select=[gender, CAST(10) AS deptno], where=[=(deptno, 10)])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSimpleCube">
    <Resource name="sql">
      <![CDATA[SELECT deptno + 1, COUNT(*) AS c FROM emp GROUP BY CUBE(deptno, gender)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[+($0, 1)], c=[$2])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], c=[COUNT()])
   +- LogicalProject(deptno=[$1], gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[+(deptno, 1) AS EXPR$0, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[$1], $e=[2]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, gender, 2 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
            +- Calc(select=[deptno, gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testFromBlogspot">
    <Resource name="sql">
      <![CDATA[
SELECT deptno, job, empno, ename, SUM(sal) sumsal,
    CASE GROUPING_ID(deptno, job, empno)
    WHEN 0 THEN CAST('grouped by deptno,job,empno,ename' as varchar)
    WHEN 1 THEN CAST('grouped by deptno,job' as varchar)
    WHEN 3 THEN CAST('grouped by deptno' as varchar)
    WHEN 7 THEN CAST('grouped by ()' as varchar)
    END gr_text
from scott_emp
    GROUP BY ROLLUP(deptno, job, (empno,ename))
    ORDER BY deptno, job, empno
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$0], sort1=[$1], sort2=[$2], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first], dir2=[ASC-nulls-first])
+- LogicalProject(deptno=[$0], job=[$1], empno=[$2], ename=[$3], sumsal=[$4], gr_text=[CASE(=($5, 0), _UTF-16LE'grouped by deptno,job,empno,ename':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =($5, 1), _UTF-16LE'grouped by deptno,job':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =($5, 3), _UTF-16LE'grouped by deptno':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =($5, 7), _UTF-16LE'grouped by ()':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", null:VARCHAR(2147483647) CHARACTER SET "UTF-16LE")])
   +- LogicalAggregate(group=[{0, 1, 2, 3}], groups=[[{0, 1, 2, 3}, {0, 1}, {0}, {}]], sumsal=[SUM($4)], agg#1=[GROUPING_ID($0, $1, $2)])
      +- LogicalProject(deptno=[$7], job=[$2], empno=[$0], ename=[$1], sal=[$5])
         +- LogicalTableScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, job, empno, ename, sumsal, CASE(=(CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 3:BIGINT), 1:BIGINT, =($e, 7:BIGINT), 3:BIGINT, 7:BIGINT), 0:BIGINT), _UTF-16LE'grouped by deptno,job,empno,ename':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =(CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 3:BIGINT), 1:BIGINT, =($e, 7:BIGINT), 3:BIGINT, 7:BIGINT), 1:BIGINT), _UTF-16LE'grouped by deptno,job':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =(CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 3:BIGINT), 1:BIGINT, =($e, 7:BIGINT), 3:BIGINT, 7:BIGINT), 3:BIGINT), _UTF-16LE'grouped by deptno':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", =(CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 3:BIGINT), 1:BIGINT, =($e, 7:BIGINT), 3:BIGINT, 7:BIGINT), 7:BIGINT), _UTF-16LE'grouped by ()':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", null:VARCHAR(2147483647) CHARACTER SET "UTF-16LE") AS gr_text])
+- Sort(orderBy=[deptno ASC, job ASC, empno ASC])
   +- Exchange(distribution=[single])
      +- HashAggregate(isMerge=[true], groupBy=[deptno, job, empno, ename, $e], select=[deptno, job, empno, ename, $e, Final_SUM(sum$0) AS sumsal])
         +- Exchange(distribution=[hash[deptno, job, empno, ename, $e]])
            +- LocalHashAggregate(groupBy=[deptno, job, empno, ename, $e], select=[deptno, job, empno, ename, $e, Partial_SUM(sal) AS sum$0])
               +- Expand(projects=[{deptno=[$0], job=[$1], empno=[$2], ename=[$3], sal=[$4], $e=[0]}, {deptno=[$0], job=[$1], empno=[null], ename=[null], sal=[$4], $e=[3]}, {deptno=[$0], job=[null], empno=[null], ename=[null], sal=[$4], $e=[7]}, {deptno=[null], job=[null], empno=[null], ename=[null], sal=[$4], $e=[15]}], projects=[{deptno, job, empno, ename, sal, 0 AS $e}, {deptno, job, null AS empno, null AS ename, sal, 3 AS $e}, {deptno, null AS job, null AS empno, null AS ename, sal, 7 AS $e}, {null AS deptno, null AS job, null AS empno, null AS ename, sal, 15 AS $e}])
                  +- Calc(select=[deptno, job, empno, ename, sal])
                     +- TableSourceScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]], fields=[empno, ename, job, mgr, hiredate, sal, comm, deptno])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingAcceptsMultipleArgumentsGivesSameResultAsGrouping_id">
    <Resource name="sql">
      <![CDATA[
SELECT COUNT(*) AS c,
    GROUPING(deptno) AS gd,
    GROUPING_ID(deptno) AS gid,
    GROUPING(deptno, gender, deptno) AS gdgd,
    GROUPING_ID(deptno, gender, deptno) AS gidgd
FROM emp
    GROUP BY ROLLUP(deptno, gender)
    HAVING GROUPING(deptno) <= GROUPING_ID(deptno, gender, deptno)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$2], gd=[$3], gid=[$4], gdgd=[$5], gidgd=[$6])
+- LogicalFilter(condition=[<=($3, $6)])
   +- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], c=[COUNT()], gd=[GROUPING($0)], gid=[GROUPING_ID($0)], gdgd=[GROUPING($0, $1, $0)], gidgd=[GROUPING_ID($0, $1, $0)])
      +- LogicalProject(deptno=[$1], gender=[$2])
         +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gd, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gid, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 2:BIGINT, 7:BIGINT) AS gdgd, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 2:BIGINT, 7:BIGINT) AS gidgd])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Calc(select=[deptno, gender, $e], where=[<=(CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT), CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 2:BIGINT, 7:BIGINT))])
            +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
               +- Calc(select=[deptno, gender])
                  +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingGroup_idGrouping_idInSelectClauseOfGroupByQuery">
    <Resource name="sql">
      <![CDATA[
SELECT COUNT(*) as c,
    GROUPING(deptno) AS g,
    GROUP_ID() AS gid,
    GROUPING_ID(deptno) AS gd,
    GROUPING_ID(gender) AS gg,
    GROUPING_ID(gender, deptno) AS ggd,
    GROUPING_ID(deptno, gender) AS gdg
FROM emp GROUP BY ROLLUP(deptno, gender)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$2], g=[$3], gid=[$4], gd=[$5], gg=[$6], ggd=[$7], gdg=[$8])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], c=[COUNT()], g=[GROUPING($0)], gid=[GROUP_ID()], gd=[GROUPING_ID($0)], gg=[GROUPING_ID($1)], ggd=[GROUPING_ID($1, $0)], gdg=[GROUPING_ID($0, $1)])
   +- LogicalProject(deptno=[$1], gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS g, 0:BIGINT AS gid, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gd, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS gg, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 2:BIGINT, 3:BIGINT) AS ggd, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, 3:BIGINT) AS gdg])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
            +- Calc(select=[deptno, gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingGrouping_idAndGroup_id">
    <Resource name="sql">
      <![CDATA[
SELECT deptno, gender,
    GROUPING(deptno) gd,
    GROUPING(gender) gg,
    GROUPING_ID(deptno, gender) dg,
    GROUPING_ID(gender, deptno) gd,
    GROUP_ID() gid,
    COUNT(*) c
FROM emp
    GROUP BY CUBE(deptno, gender)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(deptno=[$0], gender=[$1], gd=[$2], gg=[$3], dg=[$4], gd0=[$5], gid=[$6], c=[$7])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], gd=[GROUPING($0)], gg=[GROUPING($1)], dg=[GROUPING_ID($0, $1)], gd=[GROUPING_ID($1, $0)], gid=[GROUP_ID()], c=[COUNT()])
   +- LogicalProject(deptno=[$1], gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, gender, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gd, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gg, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 2:BIGINT, 3:BIGINT) AS dg, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 2:BIGINT, =($e, 2:BIGINT), 1:BIGINT, 3:BIGINT) AS gd0, 0:BIGINT AS gid, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[$1], $e=[2]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, gender, 2 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
            +- Calc(select=[deptno, gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingInSelectClauseOfCubeQuery">
    <Resource name="sql">
      <![CDATA[
SELECT deptno, job,
    COUNT(*) AS c,
    GROUPING(deptno) AS d,
    GROUPING(job) j,
    GROUPING(deptno, job) AS x
FROM scott_emp GROUP BY CUBE(deptno, job)

      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], c=[COUNT()], d=[GROUPING($0)], j=[GROUPING($1)], x=[GROUPING($0, $1)])
+- LogicalProject(deptno=[$7], job=[$2])
   +- LogicalTableScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, job, c, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS d, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS j, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 2:BIGINT, 3:BIGINT) AS x])
+- HashAggregate(isMerge=[true], groupBy=[deptno, job, $e], select=[deptno, job, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, job, $e]])
      +- LocalHashAggregate(groupBy=[deptno, job, $e], select=[deptno, job, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], job=[$1], $e=[0]}, {deptno=[$0], job=[null], $e=[1]}, {deptno=[null], job=[$1], $e=[2]}, {deptno=[null], job=[null], $e=[3]}], projects=[{deptno, job, 0 AS $e}, {deptno, null AS job, 1 AS $e}, {null AS deptno, job, 2 AS $e}, {null AS deptno, null AS job, 3 AS $e}])
            +- Calc(select=[deptno, job])
               +- TableSourceScan(table=[[default_catalog, default_database, scott_emp, source: [TestTableSource(empno, ename, job, mgr, hiredate, sal, comm, deptno)]]], fields=[empno, ename, job, mgr, hiredate, sal, comm, deptno])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingInSelectClauseOfGroupByQuery">
    <Resource name="sql">
      <![CDATA[SELECT COUNT(*) AS c, GROUPING(deptno) AS g FROM emp GROUP BY deptno]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$1], g=[$2])
+- LogicalAggregate(group=[{0}], c=[COUNT()], g=[GROUPING($0)])
   +- LogicalProject(deptno=[$1])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c, 0:BIGINT AS g])
+- HashAggregate(isMerge=[true], groupBy=[deptno], select=[deptno, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno]])
      +- LocalHashAggregate(groupBy=[deptno], select=[deptno, Partial_COUNT(*) AS count1$0])
         +- Calc(select=[deptno])
            +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingInSelectClauseOfRollupQuery">
    <Resource name="sql">
      <![CDATA[
SELECT COUNT(*) AS c, deptno, GROUPING(deptno) AS g FROM emp GROUP BY ROLLUP(deptno)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$1], deptno=[$0], g=[$2])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()], g=[GROUPING($0)])
   +- LogicalProject(deptno=[$1])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c, deptno, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS g])
+- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, $e]])
      +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
            +- Calc(select=[deptno])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingSets">
    <Resource name="sql">
      <![CDATA[
SELECT b, c, avg(a) AS a, GROUP_ID() AS g FROM MyTable
GROUP BY GROUPING SETS (b, c)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0}, {1}]], a=[AVG($2)], g=[GROUP_ID()])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[$2], $e=[2]}], projects=[{a, b, null AS c, 1 AS $e}, {a, null AS b, c, 2 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingSets2">
    <Resource name="sql">
      <![CDATA[SELECT b, c, AVG(a) AS a FROM MyTable GROUP BY GROUPING SETS (b, c, ())]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0}, {1}, {}]], a=[AVG($2)])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[$2], $e=[2]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, null AS c, 1 AS $e}, {a, null AS b, c, 2 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingSets3">
    <Resource name="sql">
      <![CDATA[
SELECT b, c,
    AVG(a) AS a,
    GROUP_ID() AS g,
    GROUPING(b) AS gb,
    GROUPING(c) AS gc,
    GROUPING_ID(b) AS gib,
    GROUPING_ID(c) AS gic,
    GROUPING_ID(b, c) AS gid,
    COUNT(*) AS cnt
FROM MyTable
     GROUP BY GROUPING SETS (b, c, ())
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0}, {1}, {}]], a=[AVG($2)], g=[GROUP_ID()], gb=[GROUPING($0)], gc=[GROUPING($1)], gib=[GROUPING_ID($0)], gic=[GROUPING_ID($1)], gid=[GROUPING_ID($0, $1)], cnt=[COUNT()])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g, CASE(=($e, 1:BIGINT), 0:BIGINT, 1:BIGINT) AS gb, CASE(=($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gc, CASE(=($e, 1:BIGINT), 0:BIGINT, 1:BIGINT) AS gib, CASE(=($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 0:BIGINT, 1:BIGINT) AS gic, CASE(=($e, 1:BIGINT), 1:BIGINT, =($e, 2:BIGINT), 2:BIGINT, 3:BIGINT) AS gid, cnt])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a, Final_COUNT(count1$2) AS cnt])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1), Partial_COUNT(*) AS count1$2])
         +- Expand(projects=[{a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[$2], $e=[2]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, null AS c, 1 AS $e}, {a, null AS b, c, 2 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingSetsOnExpression">
    <Resource name="sql">
      <![CDATA[
SELECT deptno + 1, COUNT(*) AS c FROM emps GROUP BY GROUPING SETS ((), (deptno + 1))
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
+- LogicalProject(EXPR$0=[+($2, 1)])
   +- LogicalTableScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0, c])
+- HashAggregate(isMerge=[true], groupBy=[EXPR$0, $e], select=[EXPR$0, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[EXPR$0, $e]])
      +- LocalHashAggregate(groupBy=[EXPR$0, $e], select=[EXPR$0, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{EXPR$0=[$0], $e=[0]}, {EXPR$0=[null], $e=[1]}], projects=[{EXPR$0, 0 AS $e}, {null AS EXPR$0, 1 AS $e}])
            +- Calc(select=[+(deptno, 1) AS EXPR$0])
               +- TableSourceScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]], fields=[empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingInOrderByClause">
    <Resource name="sql">
      <![CDATA[
SELECT COUNT(*) AS c FROM emp GROUP BY ROLLUP(deptno) ORDER BY GROUPING(deptno), c
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(c=[$0])
+- LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC-nulls-first], dir1=[ASC-nulls-first])
   +- LogicalProject(c=[$1], EXPR$1=[$2])
      +- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()], agg#1=[GROUPING($0)])
         +- LogicalProject(deptno=[$1])
            +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[c])
+- Sort(orderBy=[EXPR$1 ASC, c ASC])
   +- Exchange(distribution=[single])
      +- Calc(select=[c, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS EXPR$1])
         +- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
            +- Exchange(distribution=[hash[deptno, $e]])
               +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
                  +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
                     +- Calc(select=[deptno])
                        +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingSetsWithOneGrouping">
    <Resource name="sql">
      <![CDATA[
SELECT deptno,
    AVG(age) AS a,
    GROUP_ID() AS g,
    GROUPING(deptno) AS gb,
    GROUPING_ID(deptno) AS gib
FROM emps GROUP BY GROUPING SETS (deptno)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}], a=[AVG($1)], g=[GROUP_ID()], gb=[GROUPING($0)], gib=[GROUPING_ID($0)])
+- LogicalProject(deptno=[$2], age=[$6])
   +- LogicalTableScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, a, 0:BIGINT AS g, 0:BIGINT AS gb, 0:BIGINT AS gib])
+- HashAggregate(isMerge=[true], groupBy=[deptno], select=[deptno, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[deptno]])
      +- LocalHashAggregate(groupBy=[deptno], select=[deptno, Partial_AVG(age) AS (sum$0, count$1)])
         +- Calc(select=[deptno, age])
            +- TableSourceScan(table=[[default_catalog, default_database, emps, source: [TestTableSource(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)]]], fields=[empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollup">
    <Resource name="sql">
      <![CDATA[
SELECT b, c,
    AVG(a) AS a,
    GROUP_ID() AS g,
    GROUPING(b) AS gb,
    GROUPING(c) AS gc,
    GROUPING_ID(b) AS gib,
    GROUPING_ID(c) AS gic,
    GROUPING_ID(b, c) as gid
FROM MyTable
     GROUP BY ROLLUP (b, c)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], a=[AVG($2)], g=[GROUP_ID()], gb=[GROUPING($0)], gc=[GROUPING($1)], gib=[GROUPING_ID($0)], gic=[GROUPING_ID($1)], gid=[GROUPING_ID($0, $1)])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gb, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS gc, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gib, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS gic, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, 3:BIGINT) AS gid])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[$2], $e=[0]}, {a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, c, 0 AS $e}, {a, b, null AS c, 1 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupAsGroupingSets">
    <Resource name="sql">
      <![CDATA[
SELECT b, c,
    AVG(a) AS a,
    GROUP_ID() AS g,
    GROUPING(b) AS gb,
    GROUPING(c) AS gc,
    GROUPING_ID(b) AS gib,
    GROUPING_ID(c) as gic,
    GROUPING_ID(b, c) AS gid
FROM MyTable
    GROUP BY ROLLUP (b, c)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], a=[AVG($2)], g=[GROUP_ID()], gb=[GROUPING($0)], gc=[GROUPING($1)], gib=[GROUPING_ID($0)], gic=[GROUPING_ID($1)], gid=[GROUPING_ID($0, $1)])
+- LogicalProject(b=[$1], c=[$2], a=[$0])
   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[b, c, a, 0:BIGINT AS g, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gb, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS gc, CASE(OR(=($e, 0:BIGINT), =($e, 1:BIGINT)), 0:BIGINT, 1:BIGINT) AS gib, CASE(=($e, 0:BIGINT), 0:BIGINT, 1:BIGINT) AS gic, CASE(=($e, 0:BIGINT), 0:BIGINT, =($e, 1:BIGINT), 1:BIGINT, 3:BIGINT) AS gid])
+- HashAggregate(isMerge=[true], groupBy=[b, c, $e], select=[b, c, $e, Final_AVG(sum$0, count$1) AS a])
   +- Exchange(distribution=[hash[b, c, $e]])
      +- LocalHashAggregate(groupBy=[b, c, $e], select=[b, c, $e, Partial_AVG(a) AS (sum$0, count$1)])
         +- Expand(projects=[{a=[$0], b=[$1], c=[$2], $e=[0]}, {a=[$0], b=[$1], c=[null], $e=[1]}, {a=[$0], b=[null], c=[null], $e=[3]}], projects=[{a, b, c, 0 AS $e}, {a, b, null AS c, 1 AS $e}, {a, null AS b, null AS c, 3 AS $e}])
            +- TableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupCartesianProduct">
    <Resource name="sql">
      <![CDATA[SELECT deptno, COUNT(*) AS c FROM emp GROUP BY ROLLUP(deptno), ROLLUP(gender)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(deptno=[$0], c=[$2])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], c=[COUNT()])
   +- LogicalProject(deptno=[$1], gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[deptno, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[$1], $e=[2]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, gender, 2 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
            +- Calc(select=[deptno, gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupCartesianProductOfWithTupleWithExpression">
    <Resource name="sql">
      <![CDATA[
SELECT deptno / 2 + 1 AS half1, COUNT(*) AS c FROM emp
GROUP BY ROLLUP(deptno / 2, gender), ROLLUP(substring(ename FROM 1 FOR 1))
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(half1=[+($0, 1)], c=[$3])
+- LogicalAggregate(group=[{0, 1, 2}], groups=[[{0, 1, 2}, {0, 1}, {0, 2}, {0}, {2}, {}]], c=[COUNT()])
   +- LogicalProject($f0=[/($1, 2)], gender=[$2], $f2=[SUBSTRING($0, 1, 1)])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[+($f0, 1) AS half1, c])
+- HashAggregate(isMerge=[true], groupBy=[$f0, gender, $f2, $e], select=[$f0, gender, $f2, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[$f0, gender, $f2, $e]])
      +- LocalHashAggregate(groupBy=[$f0, gender, $f2, $e], select=[$f0, gender, $f2, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{$f0=[$0], gender=[$1], $f2=[$2], $e=[0]}, {$f0=[$0], gender=[$1], $f2=[null], $e=[1]}, {$f0=[$0], gender=[null], $f2=[$2], $e=[2]}, {$f0=[$0], gender=[null], $f2=[null], $e=[3]}, {$f0=[null], gender=[null], $f2=[$2], $e=[6]}, {$f0=[null], gender=[null], $f2=[null], $e=[7]}], projects=[{$f0, gender, $f2, 0 AS $e}, {$f0, gender, null AS $f2, 1 AS $e}, {$f0, null AS gender, $f2, 2 AS $e}, {$f0, null AS gender, null AS $f2, 3 AS $e}, {null AS $f0, null AS gender, $f2, 6 AS $e}, {null AS $f0, null AS gender, null AS $f2, 7 AS $e}])
            +- Calc(select=[/(deptno, 2) AS $f0, gender, SUBSTRING(ename, 1, 1) AS $f2])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupOn2Column">
    <Resource name="sql">
      <![CDATA[
SELECT gender, deptno + 1, COUNT(*) AS c FROM emp GROUP BY ROLLUP(deptno, gender)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(gender=[$1], EXPR$1=[+($0, 1)], c=[$2])
+- LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {}]], c=[COUNT()])
   +- LogicalProject(deptno=[$1], gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[gender, +(deptno, 1) AS EXPR$1, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, gender, $e]])
      +- LocalHashAggregate(groupBy=[deptno, gender, $e], select=[deptno, gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], gender=[$1], $e=[0]}, {deptno=[$0], gender=[null], $e=[1]}, {deptno=[null], gender=[null], $e=[3]}], projects=[{deptno, gender, 0 AS $e}, {deptno, null AS gender, 1 AS $e}, {null AS deptno, null AS gender, 3 AS $e}])
            +- Calc(select=[deptno, gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupOnColumnWithNulls">
    <Resource name="sql">
      <![CDATA[SELECT gender, COUNT(*) AS c FROM emp GROUP BY ROLLUP(gender)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
+- LogicalProject(gender=[$2])
   +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[gender, c])
+- HashAggregate(isMerge=[true], groupBy=[gender, $e], select=[gender, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[gender, $e]])
      +- LocalHashAggregate(groupBy=[gender, $e], select=[gender, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{gender=[$0], $e=[0]}, {gender=[null], $e=[1]}], projects=[{gender, 0 AS $e}, {null AS gender, 1 AS $e}])
            +- Calc(select=[gender])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupPlusOrderBy">
    <Resource name="sql">
      <![CDATA[SELECT gender, COUNT(*) AS c FROM emp GROUP BY ROLLUP(gender) ORDER BY c DESC]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalSort(sort0=[$1], dir0=[DESC-nulls-last])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
   +- LogicalProject(gender=[$2])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Sort(orderBy=[c DESC])
+- Exchange(distribution=[single])
   +- Calc(select=[gender, c])
      +- HashAggregate(isMerge=[true], groupBy=[gender, $e], select=[gender, $e, Final_COUNT(count1$0) AS c])
         +- Exchange(distribution=[hash[gender, $e]])
            +- LocalHashAggregate(groupBy=[gender, $e], select=[gender, $e, Partial_COUNT(*) AS count1$0])
               +- Expand(projects=[{gender=[$0], $e=[0]}, {gender=[null], $e=[1]}], projects=[{gender, 0 AS $e}, {null AS gender, 1 AS $e}])
                  +- Calc(select=[gender])
                     +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupWithHaving">
    <Resource name="sql">
      <![CDATA[
SELECT deptno + 1 AS d1, COUNT(*) AS c FROM emp GROUP BY ROLLUP(deptno) HAVING COUNT(*) > 3
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(d1=[+($0, 1)], c=[$1])
+- LogicalFilter(condition=[>($1, 3)])
   +- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
      +- LogicalProject(deptno=[$1])
         +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[+(deptno, 1) AS d1, c], where=[>(c, 3)])
+- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, $e]])
      +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
            +- Calc(select=[deptno])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testRollupOn1Column">
    <Resource name="sql">
      <![CDATA[SELECT deptno + 1, COUNT(*) AS c FROM emp GROUP BY ROLLUP(deptno)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[+($0, 1)], c=[$1])
+- LogicalAggregate(group=[{0}], groups=[[{0}, {}]], c=[COUNT()])
   +- LogicalProject(deptno=[$1])
      +- LogicalTableScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[+(deptno, 1) AS EXPR$0, c])
+- HashAggregate(isMerge=[true], groupBy=[deptno, $e], select=[deptno, $e, Final_COUNT(count1$0) AS c])
   +- Exchange(distribution=[hash[deptno, $e]])
      +- LocalHashAggregate(groupBy=[deptno, $e], select=[deptno, $e, Partial_COUNT(*) AS count1$0])
         +- Expand(projects=[{deptno=[$0], $e=[0]}, {deptno=[null], $e=[1]}], projects=[{deptno, 0 AS $e}, {null AS deptno, 1 AS $e}])
            +- Calc(select=[deptno])
               +- TableSourceScan(table=[[default_catalog, default_database, emp, source: [TestTableSource(ename, deptno, gender)]]], fields=[ename, deptno, gender])
]]>
    </Resource>
  </TestCase>
</Root>
