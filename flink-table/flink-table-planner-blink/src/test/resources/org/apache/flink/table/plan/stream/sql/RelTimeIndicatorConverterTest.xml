<?xml version="1.0" ?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<Root>
  <TestCase name="testAggregationOnProctime">
    <Resource name="sql">
      <![CDATA[SELECT MIN(proctime) FROM MyTable2 GROUP BY long]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$1])
+- LogicalAggregate(group=[{0}], EXPR$0=[MIN($1)])
   +- LogicalProject(long=[$0], proctime=[$2])
      +- LogicalTableScan(table=[[MyTable2]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0])
+- GroupAggregate(groupBy=[long], select=[long, MIN(proctime) AS EXPR$0])
   +- Exchange(distribution=[hash[long]])
      +- Calc(select=[long, PROCTIME_MATERIALIZE(proctime) AS proctime])
         +- DataStreamScan(table=[[_DataStreamTable_2]], fields=[long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testAggregationOnRowtime">
    <Resource name="sql">
      <![CDATA[SELECT MIN(rowtime) FROM MyTable1 GROUP BY long]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$1])
+- LogicalAggregate(group=[{0}], EXPR$0=[MIN($1)])
   +- LogicalProject(long=[$1], rowtime=[$0])
      +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0])
+- GroupAggregate(groupBy=[long], select=[long, MIN(rowtime) AS EXPR$0])
   +- Exchange(distribution=[hash[long]])
      +- Calc(select=[long, CAST(rowtime) AS rowtime])
         +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testFilteringOnRowtime">
    <Resource name="sql">
      <![CDATA[SELECT rowtime FROM MyTable1 WHERE rowtime > CAST('1990-12-02 12:11:11' AS TIMESTAMP)]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(rowtime=[$0])
+- LogicalFilter(condition=[>($0, CAST(_UTF-16LE'1990-12-02 12:11:11'):TIMESTAMP(3) NOT NULL)])
   +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[rowtime], where=[>(CAST(rowtime), 1990-12-02 12:11:11:TIMESTAMP(3))])
+- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingOnProctime">
    <Resource name="sql">
      <![CDATA[SELECT COUNT(long) FROM MyTable2 GROUP BY proctime]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$1])
+- LogicalAggregate(group=[{0}], EXPR$0=[COUNT($1)])
   +- LogicalProject(proctime=[$2], long=[$0])
      +- LogicalTableScan(table=[[MyTable2]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0])
+- GroupAggregate(groupBy=[proctime], select=[proctime, COUNT(long) AS EXPR$0])
   +- Exchange(distribution=[hash[proctime]])
      +- Calc(select=[PROCTIME_MATERIALIZE(proctime) AS proctime, long])
         +- DataStreamScan(table=[[_DataStreamTable_2]], fields=[long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testGroupingOnRowtime">
    <Resource name="sql">
      <![CDATA[SELECT COUNT(long) FROM MyTable GROUP BY rowtime]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$1])
+- LogicalAggregate(group=[{0}], EXPR$0=[COUNT($1)])
   +- LogicalProject(rowtime=[$0], long=[$1])
      +- LogicalTableScan(table=[[MyTable]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0])
+- GroupAggregate(groupBy=[rowtime], select=[rowtime, COUNT(long) AS EXPR$0])
   +- Exchange(distribution=[hash[rowtime]])
      +- Calc(select=[CAST(rowtime) AS rowtime, long])
         +- DataStreamScan(table=[[_DataStreamTable_0]], fields=[rowtime, long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testMultiWindow">
    <Resource name="sql">
      <![CDATA[
SELECT TUMBLE_END(newrowtime, INTERVAL '30' SECOND), long, sum(`int`) FROM (
    SELECT
        TUMBLE_ROWTIME(rowtime, INTERVAL '10' SECOND) AS newrowtime,
        long,
        sum(`int`) as `int`
    FROM MyTable1
        GROUP BY TUMBLE(rowtime, INTERVAL '10' SECOND), long
) t GROUP BY TUMBLE(newrowtime, INTERVAL '30' SECOND), long
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[TUMBLE_END($0)], long=[$1], EXPR$2=[$2])
+- LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)])
   +- LogicalProject($f0=[TUMBLE(TUMBLE_ROWTIME($0), 30000:INTERVAL SECOND)], long=[$1], int=[$2])
      +- LogicalAggregate(group=[{0, 1}], int=[SUM($2)])
         +- LogicalProject($f0=[TUMBLE($0, 10000:INTERVAL SECOND)], long=[$1], int=[$2])
            +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[CAST(w$end) AS EXPR$0, long, EXPR$2])
+- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], properties=[w$start, w$end, w$rowtime], select=[long, SUM(int) AS EXPR$2, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime])
   +- Exchange(distribution=[hash[long]])
      +- Calc(select=[CAST(w$rowtime) AS $f0, long, int])
         +- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], properties=[w$start, w$end, w$rowtime], select=[long, SUM(int) AS int, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime])
            +- Exchange(distribution=[hash[long]])
               +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSelectAll">
    <Resource name="sql">
      <![CDATA[SELECT * FROM MyTable]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(rowtime=[$0], long=[$1], int=[$2], proctime=[$3])
+- LogicalTableScan(table=[[MyTable]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[rowtime, long, int, PROCTIME_MATERIALIZE(proctime) AS proctime])
+- DataStreamScan(table=[[_DataStreamTable_0]], fields=[rowtime, long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testSimpleMaterialization">
    <Resource name="sql">
      <![CDATA[
SELECT rowtime FROM
    (SELECT FLOOR(rowtime TO DAY) AS rowtime, long FROM MyTable WHERE long > 0) t
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(rowtime=[FLOOR($0, FLAG(DAY))])
+- LogicalFilter(condition=[>($1, 0)])
   +- LogicalTableScan(table=[[MyTable]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[FLOOR(CAST(rowtime), FLAG(DAY)) AS rowtime], where=[>(long, 0)])
+- DataStreamScan(table=[[_DataStreamTable_0]], fields=[rowtime, long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testTableFunction">
    <Resource name="sql">
      <![CDATA[
SELECT rowtime, proctime, s
FROM MyTable, LATERAL TABLE(tableFunc(rowtime, proctime, '')) AS T(s)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(rowtime=[$0], proctime=[$3], s=[$4])
+- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 3}])
   :- LogicalTableScan(table=[[MyTable]])
   +- LogicalTableFunctionScan(invocation=[tableFunc($cor0.rowtime, $cor0.proctime, _UTF-16LE'')], rowType=[RecordType(VARCHAR(65536) f0)], elementType=[class [Ljava.lang.Object;])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[rowtime, PROCTIME_MATERIALIZE(proctime) AS proctime, f0 AS s])
+- Correlate(invocation=[tableFunc(CAST($cor0.rowtime):TIMESTAMP(3) NOT NULL, PROCTIME_MATERIALIZE($cor0.proctime), _UTF-16LE'')], correlate=[table(tableFunc(CAST($cor0.rowtime),PROCTIME_MATERIALIZE($cor0.proctime),_UTF-16LE''))], select=[rowtime,long,int,proctime,f0], rowType=[RecordType(TIME ATTRIBUTE(ROWTIME) rowtime, BIGINT long, INTEGER int, TIME ATTRIBUTE(PROCTIME) proctime, VARCHAR(65536) f0)], joinType=[INNER])
   +- DataStreamScan(table=[[_DataStreamTable_0]], fields=[rowtime, long, int, proctime])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testWindowWithAggregationOnRowtime">
    <Resource name="sql">
      <![CDATA[
SELECT MIN(rowtime), long FROM MyTable1
GROUP BY long, TUMBLE(rowtime, INTERVAL '0.1' SECOND)
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$2], long=[$0])
+- LogicalAggregate(group=[{0, 1}], EXPR$0=[MIN($2)])
   +- LogicalProject(long=[$1], $f1=[TUMBLE($0, 100:INTERVAL SECOND)], rowtime=[$0])
      +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0, long])
+- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], select=[long, MIN(rowtime0) AS EXPR$0])
   +- Exchange(distribution=[hash[long]])
      +- Calc(select=[long, rowtime, CAST(rowtime) AS rowtime0])
         +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testUnion">
    <Resource name="sql">
      <![CDATA[SELECT rowtime FROM MyTable1 UNION ALL SELECT rowtime FROM MyTable1]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalUnion(all=[true])
:- LogicalProject(rowtime=[$0])
:  +- LogicalTableScan(table=[[MyTable1]])
+- LogicalProject(rowtime=[$0])
   +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Union(all=[true], union=[rowtime])
:- Calc(select=[rowtime], reuse_id=[1])
:  +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
+- Reused(reference_id=[1])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testWindow">
    <Resource name="sql">
      <![CDATA[
SELECT TUMBLE_END(rowtime, INTERVAL '10' SECOND),
    long,
    SUM(`int`)
FROM MyTable1
    GROUP BY TUMBLE(rowtime, INTERVAL '10' SECOND), long
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[TUMBLE_END($0)], long=[$1], EXPR$2=[$2])
+- LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)])
   +- LogicalProject($f0=[TUMBLE($0, 10000:INTERVAL SECOND)], long=[$1], int=[$2])
      +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[CAST(w$end) AS EXPR$0, long, EXPR$2])
+- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], properties=[w$start, w$end, w$rowtime], select=[long, SUM(int) AS EXPR$2, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime])
   +- Exchange(distribution=[hash[long]])
      +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testWindowWithAggregationOnRowtimeWithHaving">
    <Resource name="sql">
      <![CDATA[
SELECT MIN(rowtime), long FROM MyTable1
GROUP BY long, TUMBLE(rowtime, INTERVAL '1' SECOND)
HAVING QUARTER(TUMBLE_END(rowtime, INTERVAL '1' SECOND)) = 1
      ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(EXPR$0=[$2], long=[$0])
+- LogicalFilter(condition=[=(EXTRACT(FLAG(QUARTER), TUMBLE_END($1)), 1)])
   +- LogicalAggregate(group=[{0, 1}], EXPR$0=[MIN($2)])
      +- LogicalProject(long=[$1], $f1=[TUMBLE($0, 1000:INTERVAL SECOND)], rowtime=[$0])
         +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[EXPR$0, long], where=[=(EXTRACT(FLAG(QUARTER), CAST(w$end)), 1:BIGINT)])
+- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], properties=[w$start, w$end, w$rowtime], select=[long, MIN(rowtime0) AS EXPR$0, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime])
   +- Exchange(distribution=[hash[long]])
      +- Calc(select=[long, rowtime, CAST(rowtime) AS rowtime0])
         +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
  <TestCase name="testWindow2">
    <Resource name="sql">
      <![CDATA[
SELECT TUMBLE_END(rowtime, INTERVAL '0.1' SECOND) AS `rowtime`,
    `long`,
   SUM(`int`)
FROM MyTable1
   GROUP BY `long`, TUMBLE(rowtime, INTERVAL '0.1' SECOND)

        ]]>
    </Resource>
    <Resource name="planBefore">
      <![CDATA[
LogicalProject(rowtime=[TUMBLE_END($1)], long=[$0], EXPR$2=[$2])
+- LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)])
   +- LogicalProject(long=[$1], $f1=[TUMBLE($0, 100:INTERVAL SECOND)], int=[$2])
      +- LogicalTableScan(table=[[MyTable1]])
]]>
    </Resource>
    <Resource name="planAfter">
      <![CDATA[
Calc(select=[CAST(w$end) AS rowtime, long, EXPR$2])
+- GroupWindowAggregate(groupBy=[long], window=[TumblingGroupWindow], properties=[w$start, w$end, w$rowtime], select=[long, SUM(int) AS EXPR$2, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime])
   +- Exchange(distribution=[hash[long]])
      +- DataStreamScan(table=[[_DataStreamTable_1]], fields=[rowtime, long, int])
]]>
    </Resource>
  </TestCase>
</Root>
