
📟AI



```yaml
containerized.master.env.KUBERNETES_MAX_CONCURRENT_REQUESTS: 200
env.java.opts.jobmanager: "-Dkubernetes.max.concurrent.requests=200"
```

### 访问 Flink 的 Web UI

可以通过 [kubernetes.rest-service.exposed.type]({{< ref "docs/deployment/config" >}}#kubernetes-rest-service-exposed-type) 配置选项以多种方式公开 Flink 的 Web UI 和 REST 终点。

- **ClusterIP**：在集群内部 IP 上公开服务。服务只能在集群内访问。如果要访问 JobManager UI 或向现有会话提交作业，需要启动本地代理。然后，您可以使用 `localhost:8081` 向会话提交 Flink 作业或查看仪表板。

```bash
$ kubectl port-forward service/<ServiceName> 8081
```

- **NodePort**：在每个节点的 IP 上的静态端口（`NodePort`）上公开服务。可以通过 `<NodeIP>:<NodePort>` 联系 JobManager 服务。

- **LoadBalancer**：使用云提供商的负载均衡器外部公开服务。由于云提供商和 Kubernetes 需要一些时间来准备负载均衡器，您可能会在客户端日志中看到一个 `NodePort` JobManager Web 界面。可以使用 `kubectl get services/<cluster-id>-rest` 获取 EXTERNAL-IP，并手动构造负载均衡器 JobManager Web 界面 `http://<EXTERNAL-IP>:8081`。

更多信息，请参阅 Kubernetes 的官方文档 [在 Kubernetes 中发布服务](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types)。

{{< hint warning >}}
根据您的环境，使用 `LoadBalancer` 类型的 REST 服务公开的 Flink 集群可能会使集群对外部公开（通常具有执行任意代码的能力）。
{{< /hint >}}

### 日志记录

Kubernetes 集成将 `conf/log4j-console.properties` 和 `conf/logback-console.xml` 作为 ConfigMap 映射到各个 Pod。对这些文件的更改将在新启动的集群中可见。

#### 访问日志

默认情况下，JobManager 和 TaskManager 将日志输出到控制台和每个 Pod 中的 `/opt/flink/log`。STDOUT 和 STDERR 输出只会重定向到控制台。可以通过以下方式访问它们：

```bash
$ kubectl logs <pod-name>
```

如果 Pod 正在运行，也可以使用 `kubectl exec -it <pod-name> bash` 进行隧道连接并查看日志或调试进程。

#### 访问 TaskManager 的日志

为了不浪费资源，Flink 会自动释放空闲的 TaskManagers。这可能使得访问相应 Pod 的日志变得更加困难。通过配置 [resourcemanager.taskmanager-timeout]({{< ref "docs/deployment/config" >}}#resourcemanager-taskmanager-timeout)，可以增加释放空闲 TaskManager 之前的时间，以便有更多时间检查日志文件。

#### 动态更改日志级别

如果已配置日志记录器以 [自动检测配置更改]({{< ref "docs/deployment/advanced/logging" >}})，则可以通过更改相应的 ConfigMap（假设集群 ID 为 `my-first-flink-cluster`）来动态调整日志级别：

```bash
$ kubectl edit cm flink-config-my-first-flink-cluster
```


🎮You
You are an expert linguist, specializing in translation from English to Chinese. This is an English to Chinese translation, please provide the Chinese translation for this text base on the background:\"apache flink\". Do not provide any explanations or text apart from the translation. English:### Using Plugins\\n\\nIn order to use [plugins]({{< ref \"docs/deployment/filesystems/plugins\" >}}), you must copy them to the correct location in the Flink JobManager/TaskManager pod.\\nYou can use the [built-in plugins]({{< ref \"docs/deployment/resource-providers/standalone/docker\" >}}#using-plugins) without mounting a volume or building a custom Docker image.\\nFor example, use the following command to enable the S3 plugin for your Flink session cluster.\\n\\n```bash\\n$ ./bin/kubernetes-session.sh\\n    -Dcontainerized.master.env.ENABLE_BUILT_IN_PLUGINS=flink-s3-fs-hadoop-{{< version >}}.jar \\\\n    -Dcontainerized.taskmanager.env.ENABLE_BUILT_IN_PLUGINS=flink-s3-fs-hadoop-{{< version >}}


📟AI
### 使用插件

要使用[插件]({{< ref "docs/deployment/filesystems/plugins" >}})，必须将它们复制到Flink JobManager/TaskManager pod的正确位置。您可以在不挂载卷或构建自定义Docker镜像的情况下使用[内置插件]({{< ref "docs/deployment/resource-providers/standalone/docker" >}}#using-plugins)。例如，要为您的Flink会话集群启用S3插件，请使用以下命令：

```bash
$ ./bin/kubernetes-session.sh \
    -Dcontainerized.master.env.ENABLE_BUILT_IN_PLUGINS=flink-s3-fs-hadoop-{{< version >}}.jar \ 
    -Dcontainerized.taskmanager.env.ENABLE_BUILT_IN_PLUGINS=flink-s3-fs-hadoop-{{< version >}}.jar
```

### 自定义Docker镜像

如果您想使用自定义Docker镜像，可以通过配置选项`kubernetes.container.image.ref`指定。Flink社区提供了一个丰富的[Flink Docker镜像]({{< ref "docs/deployment/resource-providers/standalone/docker" >}})，这可能是一个很好的起点。有关如何启用插件、添加依赖项和其他选项的更多信息，请参阅[如何定制Flink的Docker镜像]({{< ref "docs/deployment/resource-providers/standalone/docker" >}}#customize-flink-image)。

### 使用Secrets

[Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/) 是一个包含少量敏感数据（如密码、令牌或密钥）的对象。这些信息可能会放在pod规范或镜像中。在Kubernetes上的Flink可以以两种方式使用Secrets：

* 从pod中作为文件使用Secrets；
  
* 作为环境变量使用Secrets。

#### 从Pod中作为文件使用Secrets

以下命令将在启动的pod中将秘密`mysecret`挂载到路径`/path/to/secret`下：

```bash
$ ./bin/kubernetes-session.sh -Dkubernetes.secrets=mysecret:/path/to/secret
```

然后，可以在文件`/path/to/secret/username`和`/path/to/secret/password`中找到秘密`mysecret`的用户名和密码。更多详细信息，请参阅[官方Kubernetes文档](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod)。

#### 作为环境变量使用Secrets

以下命令将在启动的pod中将秘密`mysecret`作为环境变量暴露：

```bash
$ ./bin/kubernetes-session.sh -Dkubernetes.env.secretKeyRef=\\
    env:SECRET_USERNAME,secret:mysecret,key:username;\\
    env:SECRET_PASSWORD,secret:mysecret,key:password
```

环境变量`SECRET_USERNAME`包含`mysecret`秘密的用户名，而环境变量`SECRET_PASSWORD`包含`mysecret`秘密的密码。更多详细信息，请参阅[官方Kubernetes文档](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables)。

### 在Kubernetes上的高可用性

为了在Kubernetes上实现高可用性，您可以使用[现有的高可用性服务]({{< ref "docs/deployment/ha/overview" >}})。

将<a href="{{< ref "docs/deployment/config" >}}#kubernetes-jobmanager-replicas">kubernetes.jobmanager.replicas</a>的值设置为大于1，以启动备用JobManagers。这有助于实现更快的恢复。请注意，在启动备用JobManagers时应启用高可用性。


