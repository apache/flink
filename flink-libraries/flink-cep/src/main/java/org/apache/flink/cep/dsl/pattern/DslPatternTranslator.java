/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.cep.dsl.pattern;

import org.apache.flink.annotation.Internal;
import org.apache.flink.cep.dsl.api.EventAdapter;
import org.apache.flink.cep.dsl.condition.ComparisonOperator;
import org.apache.flink.cep.dsl.condition.DslCondition;
import org.apache.flink.cep.dsl.condition.DslExpression;
import org.apache.flink.cep.dsl.exception.DslCompilationException;
import org.apache.flink.cep.dsl.grammar.CepDslBaseListener;
import org.apache.flink.cep.dsl.grammar.CepDslParser;
import org.apache.flink.cep.nfa.aftermatch.AfterMatchSkipStrategy;
import org.apache.flink.cep.pattern.Pattern;

import org.antlr.v4.runtime.Token;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * Translates ANTLR parse tree to Flink Pattern objects.
 *
 * <p>This class walks the parse tree generated by ANTLR and constructs the corresponding Flink CEP
 * Pattern using the builder API. It handles:
 *
 * <ul>
 *   <li>Pattern sequencing (next, followedBy, followedByAny, notFollowedBy)
 *   <li>Conditions (where clauses with expressions)
 *   <li>Quantifiers (*, +, ?, {n}, {n,m})
 *   <li>Time windows (within)
 *   <li>Skip strategies
 * </ul>
 */
@Internal
public class DslPatternTranslator<T> extends CepDslBaseListener {

    private static final Logger LOG = LoggerFactory.getLogger(DslPatternTranslator.class);

    private final EventAdapter<T> eventAdapter;
    private final boolean strictTypeMatching;

    // Pattern building state
    private Pattern<T, T> currentPattern;
    private AfterMatchSkipStrategy skipStrategy = AfterMatchSkipStrategy.noSkip();

    // Current pattern node state
    private String currentPatternName;
    private String currentEventType;
    private List<DslExpression<T>> currentExpressions;
    private DslCondition.LogicalOperator currentLogicalOp;
    private boolean isGreedy = false;
    private boolean isOptional = false;
    private Integer quantifierLower = null;
    private Integer quantifierUpper = null;

    // Expression building stacks
    private Stack<List<DslExpression<T>>> expressionStack = new Stack<>();
    private Stack<DslCondition.LogicalOperator> operatorStack = new Stack<>();
    private Stack<BiConsumer<DslPatternTranslator<T>, Integer>> numberConsumerStack = new Stack<>();
    private Stack<BiConsumer<DslPatternTranslator<T>, String>> stringConsumerStack = new Stack<>();

    // Current expression being built
    private String currentAttribute;
    private ComparisonOperator currentOperator;
    private Object currentValue;
    private String currentRefPattern;
    private String currentRefAttribute;

    // Pattern combiner (determines how patterns are connected)
    private Function<String, Pattern<T, T>> patternCombiner;

    // Skip strategy helpers
    private static final Map<String, Function<String, AfterMatchSkipStrategy>> SKIP_STRATEGIES =
            new HashMap<>();

    static {
        SKIP_STRATEGIES.put("NO_SKIP", (ignored) -> AfterMatchSkipStrategy.noSkip());
        SKIP_STRATEGIES.put(
                "SKIP_PAST_LAST", (ignored) -> AfterMatchSkipStrategy.skipPastLastEvent());
        SKIP_STRATEGIES.put("SKIP_TO_FIRST", AfterMatchSkipStrategy::skipToFirst);
        SKIP_STRATEGIES.put("SKIP_TO_LAST", AfterMatchSkipStrategy::skipToLast);
    }

    public DslPatternTranslator(EventAdapter<T> eventAdapter, boolean strictTypeMatching) {
        this.eventAdapter = eventAdapter;
        this.strictTypeMatching = strictTypeMatching;
    }

    @Override
    public void enterSkipStrategy(CepDslParser.SkipStrategyContext ctx) {
        if (ctx.s != null) {
            String strategyName = ctx.s.getText().toUpperCase();
            String patternRef = null;

            // Extract pattern reference for SKIP_TO_FIRST/LAST
            if (ctx.stringconstant() != null) {
                patternRef = extractStringLiteral(ctx.stringconstant().getText());
            }

            Function<String, AfterMatchSkipStrategy> strategyFactory =
                    SKIP_STRATEGIES.get(strategyName);
            if (strategyFactory != null) {
                skipStrategy = strategyFactory.apply(patternRef);
                LOG.debug("Set skip strategy: {}", strategyName);
            }
        }
    }

    @Override
    public void enterPatternFilterExpression(CepDslParser.PatternFilterExpressionContext ctx) {
        // Initialize state for new pattern node
        currentPatternName = null;
        currentEventType = null;
        currentExpressions = new ArrayList<>();
        currentLogicalOp = DslCondition.LogicalOperator.AND;
        isGreedy = false;
        isOptional = false;
        quantifierLower = null;
        quantifierUpper = null;

        // Extract pattern name and event type
        if (ctx.patternFilterExpressionMandatory() != null) {
            CepDslParser.PatternFilterExpressionMandatoryContext mandatory =
                    ctx.patternFilterExpressionMandatory();
            extractPatternInfo(mandatory.classIdentifier(), mandatory.i);
            isOptional = false;
        } else if (ctx.patternFilterExpressionOptional() != null) {
            CepDslParser.PatternFilterExpressionOptionalContext optional =
                    ctx.patternFilterExpressionOptional();
            extractPatternInfo(optional.classIdentifier(), optional.i);
            isOptional = true;
        }
    }

    @Override
    public void exitPatternFilterExpression(CepDslParser.PatternFilterExpressionContext ctx) {
        // Build the pattern
        buildPattern();
    }

    private void extractPatternInfo(CepDslParser.ClassIdentifierContext classId, Token nameToken) {
        // Event type is the class identifier
        currentEventType = extractClassIdentifier(classId);

        // Pattern name is either explicitly specified or defaults to event type
        if (nameToken != null) {
            currentPatternName = nameToken.getText();
        } else {
            currentPatternName = currentEventType;
        }
    }

    private String extractClassIdentifier(CepDslParser.ClassIdentifierContext ctx) {
        if (ctx == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (CepDslParser.EscapableStrContext esc : ctx.escapableStr()) {
            if (sb.length() > 0) {
                sb.append(".");
            }
            sb.append(extractEscapableStr(esc));
        }
        return sb.toString();
    }

    private String extractEscapableStr(CepDslParser.EscapableStrContext ctx) {
        if (ctx.i1 != null) {
            return ctx.i1.getText();
        }
        if (ctx.i3 != null) {
            return extractStringLiteral(ctx.i3.getText());
        }
        return "";
    }

    private void buildPattern() {
        // Create or extend pattern
        if (currentPattern == null) {
            // First pattern - use begin()
            currentPattern = Pattern.begin(currentPatternName, skipStrategy);
            LOG.debug("Created initial pattern: {}", currentPatternName);
        } else {
            // Subsequent patterns - use combiner
            if (patternCombiner != null) {
                currentPattern = patternCombiner.apply(currentPatternName);
            } else {
                // Default to next()
                currentPattern = currentPattern.next(currentPatternName);
            }
            LOG.debug("Added pattern node: {}", currentPatternName);
        }

        // Add condition if we have expressions or need type matching
        // Use currentEventType for matching unless strictTypeMatching explicitly disables it
        String typePattern = currentEventType;
        DslCondition<T> condition =
                new DslCondition<>(eventAdapter, typePattern, currentExpressions, currentLogicalOp);
        currentPattern = currentPattern.where(condition);

        // Apply quantifiers
        applyQuantifiers();

        // Reset combiner for next pattern
        patternCombiner = null;
    }

    private void applyQuantifiers() {
        // Handle specific quantifier types
        if (quantifierLower != null && quantifierUpper != null) {
            // Range quantifier {n,m}
            if (quantifierUpper == Integer.MAX_VALUE) {
                currentPattern = currentPattern.timesOrMore(quantifierLower);
            } else {
                currentPattern = currentPattern.times(quantifierLower, quantifierUpper);
            }
        } else if (quantifierLower != null) {
            // Exact quantifier {n}
            currentPattern = currentPattern.times(quantifierLower);
        }

        // Apply optional modifier
        if (isOptional) {
            currentPattern = currentPattern.optional();
        }

        // Apply greedy modifier
        if (isGreedy) {
            currentPattern = currentPattern.greedy();
        }
    }

    @Override
    public void enterFollowedBy(CepDslParser.FollowedByContext ctx) {
        patternCombiner = name -> currentPattern.followedBy(name);
    }

    @Override
    public void enterFollowedByAny(CepDslParser.FollowedByAnyContext ctx) {
        patternCombiner = name -> currentPattern.followedByAny(name);
    }

    @Override
    public void enterNotFollowedBy(CepDslParser.NotFollowedByContext ctx) {
        patternCombiner = name -> currentPattern.notFollowedBy(name);
    }

    @Override
    public void enterPlus_quantifier(CepDslParser.Plus_quantifierContext ctx) {
        // Mark that we need to apply oneOrMore quantifier
        quantifierLower = 1;
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterStar_quantifier(CepDslParser.Star_quantifierContext ctx) {
        // Mark that we need to apply zeroOrMore quantifier
        quantifierLower = 0;
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterNumber_quantifier(CepDslParser.Number_quantifierContext ctx) {
        // Will be handled when number constants are encountered
        numberConsumerStack.push(
                (t, v) -> {
                    if (t.quantifierLower == null) {
                        t.quantifierLower = v;
                    } else {
                        t.quantifierUpper = v;
                    }
                });
    }

    @Override
    public void exitNumber_quantifier(CepDslParser.Number_quantifierContext ctx) {
        numberConsumerStack.pop();
    }

    @Override
    public void enterNumber_quantifier_greedy(CepDslParser.Number_quantifier_greedyContext ctx) {
        isGreedy = true;
        enterNumber_quantifier(null);
    }

    @Override
    public void exitNumber_quantifier_greedy(CepDslParser.Number_quantifier_greedyContext ctx) {
        exitNumber_quantifier(null);
    }

    @Override
    public void enterUpper_bound_unlimited(CepDslParser.Upper_bound_unlimitedContext ctx) {
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterEvalOrExpression(CepDslParser.EvalOrExpressionContext ctx) {
        // Only set OR if there's actually an OR operator
        if (ctx.op != null || (ctx.getChildCount() > 1 && ctx.getText().contains("or"))) {
            currentLogicalOp = DslCondition.LogicalOperator.OR;
        }
    }

    @Override
    public void enterEvalAndExpression(CepDslParser.EvalAndExpressionContext ctx) {
        // Only override if we haven't already set OR
        if (currentLogicalOp != DslCondition.LogicalOperator.OR) {
            currentLogicalOp = DslCondition.LogicalOperator.AND;
        }
    }

    @Override
    public void enterEvalEqualsExpression(CepDslParser.EvalEqualsExpressionContext ctx) {
        // Determine operator
        if (ctx.eq != null) {
            currentOperator = ComparisonOperator.EQUALS;
        } else if (ctx.ne != null) {
            currentOperator = ComparisonOperator.NOT_EQUALS;
        }
    }

    @Override
    public void enterEvalRelationalExpression(CepDslParser.EvalRelationalExpressionContext ctx) {
        if (ctx.r != null) {
            String op = ctx.r.getText();
            currentOperator = ComparisonOperator.fromSymbol(op);
        }
    }

    @Override
    public void exitEvalEqualsExpression(CepDslParser.EvalEqualsExpressionContext ctx) {
        // Create expression if we have all parts
        if (currentAttribute != null && currentOperator != null) {
            DslExpression<T> expr;
            if (currentRefPattern != null) {
                expr =
                        new DslExpression<>(
                                currentAttribute,
                                currentOperator,
                                currentRefPattern,
                                currentRefAttribute);
            } else {
                expr = new DslExpression<>(currentAttribute, currentOperator, currentValue);
            }
            currentExpressions.add(expr);
            LOG.trace("Added expression: {}", expr);

            // Reset expression state
            currentAttribute = null;
            currentOperator = null;
            currentValue = null;
            currentRefPattern = null;
            currentRefAttribute = null;
        }
    }

    @Override
    public void enterEventPropertyIdent(CepDslParser.EventPropertyIdentContext ctx) {
        String ident = extractEventProperty(ctx);
        if (currentAttribute == null) {
            currentAttribute = ident;
        } else if (currentRefPattern == null) {
            currentRefPattern = currentAttribute;
            currentRefAttribute = ident;
        }
    }

    private String extractEventProperty(CepDslParser.EventPropertyIdentContext ctx) {
        // Simple extraction - can be enhanced for complex properties
        if (ctx.ipi != null) {
            return ctx.ipi.getText();
        }
        return ctx.getText();
    }

    @Override
    public void exitNumberconstant(CepDslParser.NumberconstantContext ctx) {
        try {
            int value = Integer.parseInt(ctx.getText());
            if (!numberConsumerStack.isEmpty()) {
                numberConsumerStack.peek().accept(this, value);
            } else {
                currentValue = value;
            }
        } catch (NumberFormatException e) {
            currentValue = Double.parseDouble(ctx.getText());
        }
    }

    @Override
    public void exitStringconstant(CepDslParser.StringconstantContext ctx) {
        String value = extractStringLiteral(ctx.getText());
        currentValue = value;
    }

    @Override
    public void exitConstant(CepDslParser.ConstantContext ctx) {
        if (ctx.t != null) {
            currentValue = true;
        } else if (ctx.f != null) {
            currentValue = false;
        } else if (ctx.nu != null) {
            currentValue = null;
        }
    }

    @Override
    public void enterTimeWindow(CepDslParser.TimeWindowContext ctx) {
        // Extract time value and unit
        int timeValue = Integer.parseInt(ctx.c.getText());
        String unit = ctx.u.getText();

        Duration duration;
        switch (unit.toLowerCase()) {
            case "h":
                duration = Duration.ofHours(timeValue);
                break;
            case "m":
                duration = Duration.ofMinutes(timeValue);
                break;
            case "s":
                duration = Duration.ofSeconds(timeValue);
                break;
            case "ms":
                duration = Duration.ofMillis(timeValue);
                break;
            default:
                throw new DslCompilationException("Unknown time unit: " + unit);
        }

        if (currentPattern != null) {
            currentPattern = currentPattern.within(duration);
            LOG.debug("Added time window: {} {}", timeValue, unit);
        }
    }

    private String extractStringLiteral(String text) {
        if (text == null || text.length() < 2) {
            return text;
        }
        // Remove quotes
        return text.substring(1, text.length() - 1);
    }

    public Pattern<T, T> getPattern() {
        return currentPattern;
    }
}
