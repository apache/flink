/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.cep.dsl.pattern;

import org.apache.flink.annotation.Internal;
import org.apache.flink.cep.dsl.api.EventAdapter;
import org.apache.flink.cep.dsl.condition.ComparisonOperator;
import org.apache.flink.cep.dsl.condition.DslCondition;
import org.apache.flink.cep.dsl.condition.DslExpression;
import org.apache.flink.cep.dsl.exception.DslCompilationException;
import org.apache.flink.cep.dsl.grammar.CepDslBaseListener;
import org.apache.flink.cep.dsl.grammar.CepDslParser;
import org.apache.flink.cep.nfa.aftermatch.AfterMatchSkipStrategy;
import org.apache.flink.cep.pattern.Pattern;

import org.antlr.v4.runtime.Token;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * Translates ANTLR parse tree to Flink Pattern objects.
 *
 * <p>This class walks the parse tree generated by ANTLR and constructs the corresponding Flink CEP
 * Pattern using the builder API. It handles:
 *
 * <ul>
 *   <li>Pattern sequencing (next, followedBy, followedByAny, notFollowedBy)
 *   <li>Conditions (where clauses with expressions)
 *   <li>Quantifiers (*, +, ?, {n}, {n,m})
 *   <li>Time windows (within)
 *   <li>Skip strategies
 * </ul>
 */
@Internal
public class DslPatternTranslator<T> extends CepDslBaseListener {

    private static final Logger LOG = LoggerFactory.getLogger(DslPatternTranslator.class);

    private final EventAdapter<T> eventAdapter;
    private final boolean strictTypeMatching;

    // Pattern building state
    private Pattern<T, T> currentPattern;
    private AfterMatchSkipStrategy skipStrategy = AfterMatchSkipStrategy.noSkip();

    // Current pattern node state
    private String currentPatternName;
    private String currentEventType;
    private List<DslExpression<T>> currentExpressions;
    private DslCondition.LogicalOperator currentLogicalOp;
    private boolean isGreedy = false;
    private boolean isOptional = false;
    private Integer quantifierLower = null;
    private Integer quantifierUpper = null;

    // Expression building stacks
    private Stack<List<DslExpression<T>>> expressionStack = new Stack<>();
    private Stack<DslCondition.LogicalOperator> operatorStack = new Stack<>();
    private Stack<BiConsumer<DslPatternTranslator<T>, Integer>> numberConsumerStack = new Stack<>();
    private Stack<BiConsumer<DslPatternTranslator<T>, String>> stringConsumerStack = new Stack<>();

    // Current expression being built
    private String currentAttribute;
    private ComparisonOperator currentOperator;
    private Object currentValue;
    private String currentRefPattern;
    private String currentRefAttribute;
    private boolean inRelationalExpression = false;
    private String
            tempClassIdText; // Temporary storage for class identifier when determining pattern name

    // Pattern combiner (determines how patterns are connected)
    private Function<String, Pattern<T, T>> patternCombiner;

    // Track used pattern names to avoid conflicts when same event type is used multiple times
    private final Map<String, Integer> usedPatternNames = new HashMap<>();

    // Skip strategy helpers
    private static final Map<String, Function<String, AfterMatchSkipStrategy>> SKIP_STRATEGIES =
            new HashMap<>();

    static {
        SKIP_STRATEGIES.put("NO_SKIP", (ignored) -> AfterMatchSkipStrategy.noSkip());
        SKIP_STRATEGIES.put(
                "SKIP_PAST_LAST", (ignored) -> AfterMatchSkipStrategy.skipPastLastEvent());
        SKIP_STRATEGIES.put("SKIP_TO_FIRST", AfterMatchSkipStrategy::skipToFirst);
        SKIP_STRATEGIES.put("SKIP_TO_LAST", AfterMatchSkipStrategy::skipToLast);
    }

    public DslPatternTranslator(EventAdapter<T> eventAdapter, boolean strictTypeMatching) {
        this.eventAdapter = eventAdapter;
        this.strictTypeMatching = strictTypeMatching;
    }

    @Override
    public void enterSkipStrategy(CepDslParser.SkipStrategyContext ctx) {
        if (ctx.s != null) {
            String strategyName = ctx.s.getText().toUpperCase();
            String patternRef = null;

            // Extract pattern reference for SKIP_TO_FIRST/LAST
            if (ctx.stringconstant() != null) {
                patternRef = extractStringLiteral(ctx.stringconstant().getText());
            }

            Function<String, AfterMatchSkipStrategy> strategyFactory =
                    SKIP_STRATEGIES.get(strategyName);
            if (strategyFactory != null) {
                skipStrategy = strategyFactory.apply(patternRef);
                LOG.debug("Set skip strategy: {}", strategyName);
            }
        }
    }

    @Override
    public void enterPatternFilterExpression(CepDslParser.PatternFilterExpressionContext ctx) {
        // Initialize state for new pattern node
        currentPatternName = null;
        currentEventType = null;
        currentExpressions = new ArrayList<>();
        currentLogicalOp = DslCondition.LogicalOperator.AND;
        isGreedy = false;
        isOptional = false;
        quantifierLower = null;
        quantifierUpper = null;

        // Extract pattern name and event type
        if (ctx.patternFilterExpressionMandatory() != null) {
            CepDslParser.PatternFilterExpressionMandatoryContext mandatory =
                    ctx.patternFilterExpressionMandatory();

            if (mandatory.i != null) {
                // Explicit name token provided
                extractPatternInfo(mandatory.classIdentifier(), mandatory.i);
            } else {
                // No explicit name - store classId for later determination
                tempClassIdText = extractClassIdentifier(mandatory.classIdentifier());
            }
            isOptional = false;
        } else if (ctx.patternFilterExpressionOptional() != null) {
            CepDslParser.PatternFilterExpressionOptionalContext optional =
                    ctx.patternFilterExpressionOptional();
            extractPatternInfo(optional.classIdentifier(), optional.i);
            isOptional = true;
        }
    }

    @Override
    public void exitPatternFilterExpression(CepDslParser.PatternFilterExpressionContext ctx) {
        // Handle pattern name detection for cases like "A(price > 0)" where A is pattern name
        if (currentPatternName == null
                && tempClassIdText != null
                && !currentExpressions.isEmpty()) {
            // Check if this looks like pattern name syntax (simple identifier with expressions)
            CepDslParser.ClassIdentifierContext classId =
                    ctx.patternFilterExpressionMandatory().classIdentifier();
            if (classId.escapableStr().size() == 1 && classId.escapableStr().get(0).i1 != null) {
                // Use the identifier as pattern name, and set event type to null (any type)
                currentPatternName = tempClassIdText;
                currentEventType = null;
            } else {
                // Normal case: use classId as event type and generate pattern name
                currentEventType = tempClassIdText;
                currentPatternName = generateUniquePatternName(currentEventType);
            }
            tempClassIdText = null; // Clean up
        }

        // Build the pattern
        buildPattern();
    }

    private void extractPatternInfo(CepDslParser.ClassIdentifierContext classId, Token nameToken) {
        // Event type is the class identifier
        String classIdText = extractClassIdentifier(classId);

        // Pattern name is either explicitly specified or defaults to event type
        if (nameToken != null) {
            currentPatternName = nameToken.getText();
            currentEventType = classIdText;
        } else {
            // Normal case: classId is event type
            currentEventType = classIdText;
            currentPatternName = generateUniquePatternName(currentEventType);
        }
    }

    /**
     * Generate a unique pattern name based on the event type. If the name is used for the first
     * time, return it as-is. Otherwise, append a counter (e.g., TRADE, TRADE_2, TRADE_3).
     */
    private String generateUniquePatternName(String baseName) {
        Integer count = usedPatternNames.get(baseName);
        if (count == null) {
            // First use - no suffix needed
            usedPatternNames.put(baseName, 1);
            return baseName;
        } else {
            // Subsequent use - add suffix
            count++;
            usedPatternNames.put(baseName, count);
            return baseName + "_" + count;
        }
    }

    private String extractClassIdentifier(CepDslParser.ClassIdentifierContext ctx) {
        if (ctx == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (CepDslParser.EscapableStrContext esc : ctx.escapableStr()) {
            if (sb.length() > 0) {
                sb.append(".");
            }
            sb.append(extractEscapableStr(esc));
        }
        return sb.toString();
    }

    private String extractEscapableStr(CepDslParser.EscapableStrContext ctx) {
        if (ctx.i1 != null) {
            return ctx.i1.getText();
        }
        if (ctx.i3 != null) {
            return extractStringLiteral(ctx.i3.getText());
        }
        return "";
    }

    private void buildPattern() {
        // Create or extend pattern
        if (currentPattern == null) {
            // First pattern - use begin()
            currentPattern = Pattern.begin(currentPatternName, skipStrategy);
            LOG.debug("Created initial pattern: {}", currentPatternName);
        } else {
            // Subsequent patterns - use combiner
            if (patternCombiner != null) {
                currentPattern = patternCombiner.apply(currentPatternName);
            } else {
                // Default to next()
                currentPattern = currentPattern.next(currentPatternName);
            }
            LOG.debug("Added pattern node: {}", currentPatternName);
        }

        // Add condition if we have expressions or need type matching
        // Use currentEventType for matching unless strictTypeMatching explicitly disables it
        String typePattern = currentEventType;
        LOG.debug(
                "Building pattern '{}' with eventType '{}' and {} expressions",
                currentPatternName,
                typePattern,
                currentExpressions.size());
        for (DslExpression<T> expr : currentExpressions) {
            LOG.debug("  Expression: {}", expr);
        }
        DslCondition<T> condition =
                new DslCondition<>(eventAdapter, typePattern, currentExpressions, currentLogicalOp);
        currentPattern = currentPattern.where(condition);

        // Apply quantifiers
        applyQuantifiers();

        // Reset combiner for next pattern
        patternCombiner = null;
    }

    private void applyQuantifiers() {
        // Handle specific quantifier types
        if (quantifierLower != null && quantifierUpper != null) {
            // Range quantifier {n,m}
            if (quantifierUpper == Integer.MAX_VALUE) {
                currentPattern = currentPattern.timesOrMore(quantifierLower);
            } else {
                currentPattern = currentPattern.times(quantifierLower, quantifierUpper);
            }
        } else if (quantifierLower != null) {
            // Exact quantifier {n}
            currentPattern = currentPattern.times(quantifierLower);
        }

        // Apply optional modifier
        if (isOptional) {
            currentPattern = currentPattern.optional();
        }

        // Apply greedy modifier
        if (isGreedy) {
            currentPattern = currentPattern.greedy();
        }
    }

    @Override
    public void enterFollowedBy(CepDslParser.FollowedByContext ctx) {
        patternCombiner = name -> currentPattern.followedBy(name);
    }

    @Override
    public void enterFollowedByAny(CepDslParser.FollowedByAnyContext ctx) {
        patternCombiner = name -> currentPattern.followedByAny(name);
    }

    @Override
    public void enterNotFollowedBy(CepDslParser.NotFollowedByContext ctx) {
        patternCombiner = name -> currentPattern.notFollowedBy(name);
    }

    @Override
    public void enterPlus_quantifier(CepDslParser.Plus_quantifierContext ctx) {
        quantifierLower = 1;
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterStar_quantifier(CepDslParser.Star_quantifierContext ctx) {
        quantifierLower = 0;
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterNumber_quantifier(CepDslParser.Number_quantifierContext ctx) {
        // Will be handled when number constants are encountered
        numberConsumerStack.push(
                (t, v) -> {
                    if (t.quantifierLower == null) {
                        t.quantifierLower = v;
                    } else {
                        t.quantifierUpper = v;
                    }
                });
    }

    @Override
    public void exitNumber_quantifier(CepDslParser.Number_quantifierContext ctx) {
        numberConsumerStack.pop();
    }

    @Override
    public void enterNumber_quantifier_greedy(CepDslParser.Number_quantifier_greedyContext ctx) {
        isGreedy = true;
        enterNumber_quantifier(null);
    }

    @Override
    public void exitNumber_quantifier_greedy(CepDslParser.Number_quantifier_greedyContext ctx) {
        exitNumber_quantifier(null);
    }

    @Override
    public void enterUpper_bound_unlimited(CepDslParser.Upper_bound_unlimitedContext ctx) {
        quantifierUpper = Integer.MAX_VALUE;
    }

    @Override
    public void enterEvalOrExpression(CepDslParser.EvalOrExpressionContext ctx) {
        // If this OR expression has multiple AND expressions, use OR logic
        // Check if there are multiple operands (separated by OR)
        System.out.println(
                "DEBUG: enterEvalOrExpression with "
                        + ctx.evalAndExpression().size()
                        + " AND expressions");
        if (ctx.evalAndExpression().size() > 1) {
            currentLogicalOp = DslCondition.LogicalOperator.OR;
            System.out.println("DEBUG: Set logical operator to OR");
        }
    }

    @Override
    public void enterEvalAndExpression(CepDslParser.EvalAndExpressionContext ctx) {
        currentLogicalOp = DslCondition.LogicalOperator.AND;
    }

    @Override
    public void enterEvalEqualsExpression(CepDslParser.EvalEqualsExpressionContext ctx) {
        // Determine operator
        if (ctx.eq != null) {
            currentOperator = ComparisonOperator.EQUALS;
        } else if (ctx.ne != null) {
            currentOperator = ComparisonOperator.NOT_EQUALS;
        }
    }

    @Override
    public void enterEvalRelationalExpression(CepDslParser.EvalRelationalExpressionContext ctx) {
        if (ctx.r != null) {
            String op = ctx.r.getText();
            currentOperator = ComparisonOperator.fromSymbol(op);
        }
        inRelationalExpression = true;
    }

    @Override
    public void exitEvalRelationalExpression(CepDslParser.EvalRelationalExpressionContext ctx) {
        // Only create expressions for actual relational operations (>, <, >=, <=)
        // Simple equals expressions are handled in exitEvalEqualsExpression
        if (ctx.r != null && currentAttribute != null && currentOperator != null) {
            DslExpression<T> expr;
            if (currentRefPattern != null) {
                // Event reference: currentAttribute > currentRefPattern.currentRefAttribute
                expr =
                        new DslExpression<>(
                                currentAttribute,
                                currentOperator,
                                currentRefPattern,
                                currentRefAttribute);
            } else if (currentValue != null) {
                // Constant comparison: currentAttribute > currentValue
                expr = new DslExpression<>(currentAttribute, currentOperator, currentValue);
            } else {
                // Invalid state - skip expression creation
                System.out.println(
                        "DEBUG: Skipping relational expression creation - currentAttribute: "
                                + currentAttribute
                                + ", currentOperator: "
                                + currentOperator
                                + ", currentValue: "
                                + currentValue
                                + ", currentRefPattern: "
                                + currentRefPattern);
                inRelationalExpression = false;
                return;
            }
            currentExpressions.add(expr);
            System.out.println("DEBUG: Created relational expression: " + expr);

            // Reset state
            currentAttribute = null;
            currentOperator = null;
            currentValue = null;
            currentRefPattern = null;
            currentRefAttribute = null;
        }
        inRelationalExpression = false;
    }

    @Override
    public void exitEvalEqualsExpression(CepDslParser.EvalEqualsExpressionContext ctx) {
        // Create expression for equals operations
        System.out.println(
                "DEBUG: exitEvalEqualsExpression - currentAttribute: "
                        + currentAttribute
                        + ", currentOperator: "
                        + currentOperator
                        + ", currentValue: "
                        + currentValue
                        + ", currentRefPattern: "
                        + currentRefPattern);
        if (currentAttribute != null && currentOperator != null && currentValue != null) {
            DslExpression<T> expr;
            if (currentRefPattern != null) {
                expr =
                        new DslExpression<>(
                                currentAttribute,
                                currentOperator,
                                currentRefPattern,
                                currentRefAttribute);
            } else {
                expr = new DslExpression<>(currentAttribute, currentOperator, currentValue);
            }
            currentExpressions.add(expr);
            System.out.println("DEBUG: Created equals expression: " + expr);

            // Reset state
            currentAttribute = null;
            currentOperator = null;
            currentValue = null;
            currentRefPattern = null;
            currentRefAttribute = null;
        } else {
            System.out.println("DEBUG: Cannot create equals expression - missing components");
        }
    }

    @Override
    public void enterEventPropertyIdent(CepDslParser.EventPropertyIdentContext ctx) {
        String ident = extractEventProperty(ctx);

        // Check if this is part of an event reference (e.g., START.price)
        if (ctx.getParent() != null && ctx.getParent().getParent() != null) {
            org.antlr.v4.runtime.tree.ParseTree grandParent = ctx.getParent().getParent();

            // If grandparent has 3 children and middle one is DOT, it's an event reference
            if (grandParent.getChildCount() == 3) {
                String fullText = grandParent.getText();
                if (fullText.contains(".")) {
                    String[] parts = fullText.split("\\.");
                    if (parts.length == 2) {
                        String refPattern = parts[0];
                        String refAttribute = parts[1];

                        // Only process when current ident matches the attribute part (second part)
                        if (ident.equals(refAttribute)) {
                            // This is the attribute part of event reference
                            if (currentAttribute != null && currentOperator != null) {
                                // Right side reference: price > START.price
                                currentRefPattern = refPattern;
                                currentRefAttribute = refAttribute;
                            } else {
                                // Left side reference: START.price > 100
                                currentAttribute = refAttribute;
                            }
                            return; // Skip normal processing - THIS IS CRITICAL!
                        } else if (ident.equals(refPattern)) {
                            // This is the pattern name part, skip it
                            return; // Skip normal processing - THIS IS CRITICAL!
                        }
                    }
                }
            }
        }

        // Normal processing for simple attributes
        if (currentAttribute == null) {
            currentAttribute = ident;
        } else if (currentRefPattern == null) {
            // Only set if different to avoid duplicate calls
            if (!ident.equals(currentAttribute)) {
                currentRefPattern = currentAttribute;
                currentRefAttribute = ident;
            }
        }
    }

    private String extractEventProperty(CepDslParser.EventPropertyIdentContext ctx) {
        // Simple extraction - can be enhanced for complex properties
        if (ctx.ipi != null) {
            return ctx.ipi.getText();
        }
        return ctx.getText();
    }

    @Override
    public void exitNumberconstant(CepDslParser.NumberconstantContext ctx) {
        try {
            int value = Integer.parseInt(ctx.getText());
            if (!numberConsumerStack.isEmpty()) {
                numberConsumerStack.peek().accept(this, value);
            } else {
                currentValue = value;
            }
        } catch (NumberFormatException e) {
            currentValue = Double.parseDouble(ctx.getText());
        }

        // Check if we can create an expression now that we have the value
        // Only create if we're not in a relational expression (those are handled in
        // exitEvalRelationalExpression)
        if (!inRelationalExpression
                && currentAttribute != null
                && currentOperator != null
                && currentValue != null) {
            DslExpression<T> expr;
            if (currentRefPattern != null) {
                expr =
                        new DslExpression<>(
                                currentAttribute,
                                currentOperator,
                                currentRefPattern,
                                currentRefAttribute);
            } else {
                expr = new DslExpression<>(currentAttribute, currentOperator, currentValue);
            }
            currentExpressions.add(expr);

            // Reset state
            currentAttribute = null;
            currentOperator = null;
            currentValue = null;
            currentRefPattern = null;
            currentRefAttribute = null;
        }
    }

    @Override
    public void exitStringconstant(CepDslParser.StringconstantContext ctx) {
        String value = extractStringLiteral(ctx.getText());
        System.out.println(
                "DEBUG: exitStringconstant: ctx.getText()='"
                        + ctx.getText()
                        + "', extracted value='"
                        + value
                        + "'");
        currentValue = value;
        System.out.println("DEBUG: Set currentValue to: " + currentValue);
    }

    @Override
    public void exitConstant(CepDslParser.ConstantContext ctx) {
        if (ctx.t != null) {
            currentValue = true;
        } else if (ctx.f != null) {
            currentValue = false;
        } else if (ctx.nu != null) {
            currentValue = null;
        }

        // Check if we can create an expression now that we have the value
        // Only create if we're not in a relational expression (those are handled in
        // exitEvalRelationalExpression)
        if (!inRelationalExpression
                && currentAttribute != null
                && currentOperator != null
                && currentValue != null) {
            DslExpression<T> expr;
            if (currentRefPattern != null) {
                expr =
                        new DslExpression<>(
                                currentAttribute,
                                currentOperator,
                                currentRefPattern,
                                currentRefAttribute);
            } else {
                expr = new DslExpression<>(currentAttribute, currentOperator, currentValue);
            }
            currentExpressions.add(expr);

            // Reset state
            currentAttribute = null;
            currentOperator = null;
            currentValue = null;
            currentRefPattern = null;
            currentRefAttribute = null;
        }
    }

    @Override
    public void enterTimeWindow(CepDslParser.TimeWindowContext ctx) {
        // Extract time value and unit
        int timeValue = Integer.parseInt(ctx.c.getText());
        String unit = ctx.u.getText();

        Duration duration;
        switch (unit.toLowerCase()) {
            case "h":
                duration = Duration.ofHours(timeValue);
                break;
            case "m":
                duration = Duration.ofMinutes(timeValue);
                break;
            case "s":
                duration = Duration.ofSeconds(timeValue);
                break;
            case "ms":
                duration = Duration.ofMillis(timeValue);
                break;
            default:
                throw new DslCompilationException("Unknown time unit: " + unit);
        }

        if (currentPattern != null) {
            currentPattern = currentPattern.within(duration);
            LOG.debug("Added time window: {} {}", timeValue, unit);
        }
    }

    private String extractStringLiteral(String text) {
        if (text == null || text.length() < 2) {
            return text;
        }
        // Remove quotes
        return text.substring(1, text.length() - 1);
    }

    public Pattern<T, T> getPattern() {
        return currentPattern;
    }
}
