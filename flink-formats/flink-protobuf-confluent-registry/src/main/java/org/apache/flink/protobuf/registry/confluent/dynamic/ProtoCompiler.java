/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.protobuf.registry.confluent.dynamic;

import com.github.os72.protocjar.Protoc;
import com.google.protobuf.DescriptorProtos;
import com.google.protobuf.Descriptors;
import io.confluent.kafka.schemaregistry.protobuf.ProtobufSchema;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service to expose the functionality of the Protoc compiler.
 */
public class ProtoCompiler {
    // Avoid clashes with classes generated by other threads in the same JVM
    private final String classSuffix;
    // The directory where all the generated files will be written to
    private final Path parentDir;
    private final Path protosDir;
    private final Path classesDir;
    private final Path confluentProtosDir;
    private final String protocVersion;

    private final static String CONFLUENT = "confluent";
    // TODO: Hava constructor that can fetch the protocVersion from project properties
    private final static String DEFAULT_PROTOC_VERSION = "3.21.7";

    public ProtoCompiler(Path parentDir, String protocVersion, String classSuffix) {
        this.classSuffix = classSuffix;
        this.parentDir = parentDir;
        this.protosDir = createChildDir(parentDir, "protos");
        this.classesDir = createChildDir(parentDir, "classes");
        this.confluentProtosDir = createChildDir(parentDir, CONFLUENT);
        this.protocVersion = protocVersion;
        this.copyConfluentProto(String.format("/%s/%s", CONFLUENT, "meta.proto"));
        this.copyConfluentProto(String.format("/%s/%s/%s", CONFLUENT, "type", "decimal.proto"));
    }

    public ProtoCompiler(String protocVersion, String classSuffix) {
        this(createParentDir(), protocVersion, classSuffix);
    }

    public ProtoCompiler() {
        this(DEFAULT_PROTOC_VERSION, generateClassSuffix());
    }

    public ProtoCompiler(String classSuffix) {
        this(DEFAULT_PROTOC_VERSION, classSuffix);
    }

    /**
     * Given a protobuf schema this method will:
     * 1. Write the schema to a .proto file in a temporary directory
     * 2. Generate the Java class definition using protoc
     * 3. Compile a Java class from the Java source file
     * 4. Load the class into the JVM
     *
     * @return the Class of the generated message type
     */
    public Class generateMessageClass(ProtobufSchema protobufSchema, int schemaId) {
        Path schemaFilePath = writeProto(protobufSchema, schemaId);

        String indexedClassName = schemaFilePath.getFileName().toString().replace(".proto", "");
        Path javaOutDir = generateJavaClassDef(schemaFilePath, indexedClassName);

        String packageName = protobufSchema.rawSchema().getPackageName();
        Path javaClassDefPath = getJavaClassDefPath(javaOutDir, packageName, indexedClassName);

        String topLevelClassName = packageName + "." + indexedClassName;
        compileJavaClass(javaClassDefPath, topLevelClassName);

        String nestedClassName = topLevelClassName + "$" + getClassNameFromProto(protobufSchema);
        return loadClass(javaOutDir, topLevelClassName, nestedClassName);
    }

    private Class loadClass(Path javaOutDir, String topLevelClassName, String nestedClassName) {
        try {
            URL classUrl = javaOutDir.toFile().toURI().toURL();
            URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{classUrl}, Thread.currentThread().getContextClassLoader());
            Thread.currentThread().setContextClassLoader(classLoader);
            classLoader.loadClass(topLevelClassName);
            return Class.forName(nestedClassName, true, classLoader);
        } catch (Exception e) {
            throw new RuntimeException("Failed to load class " + nestedClassName, e);
        }
    }

    private void compileJavaClass(Path javaClassDefPath, String topLevelClassName) {
        // Tried using {@link PbUtils}'s existing compiler but was getting errors.
        // Assignment conversion not possible from type "java.lang.Object" to type "com.google.protobuf.Descriptors$Descriptor"
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        int result = compiler.run(null, null, null, javaClassDefPath.toString());
        if (result != 0) {
            throw new RuntimeException("Failed to compile class " + topLevelClassName);
        }
    }

    private Path getJavaClassDefPath(Path javaOutDir, String packageName, String className) {
        if (packageName == null || packageName.isEmpty()) {
            return javaOutDir.resolve(className + ".java");
        } else {
            return javaOutDir.resolve(packageName.replace(".", "/")).resolve(className + ".java");
        }
    }

    private Path generateJavaClassDef(Path schemaFilePath, String className) {
        Path javaOutDir = createChildDir(classesDir, className);
        String[] args = {
                "--include_std_types",  // include google types
                "-I" + parentDir.toString(), // include confluent types
                "-v" + protocVersion,
                "--java_out=" + javaOutDir.toString(),
                "--proto_path=" + protosDir.toString(),
                schemaFilePath.toString()
        };
        try {
            int result = Protoc.runProtoc(args);
            if (result != 0) {
                throw new RuntimeException("Failed to run protoc for " + schemaFilePath);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to run protoc for " + schemaFilePath, e);
        }
        return javaOutDir;
    }

    private Path writeProto(ProtobufSchema protobufSchema, int schemaId)  {
        String className = getClassNameFromProto(protobufSchema) + "_" + schemaId + "_" + classSuffix;
        ProtobufSchema withJavaOuterClassName = setProtoOptions(protobufSchema, className);
        String schema = withJavaOuterClassName.rawSchema().toSchema();
        String schemaFileName = className + ".proto";
        Path schemaFilePath = protosDir.resolve(schemaFileName);
        try {
            java.io.FileWriter myWriter = new java.io.FileWriter(schemaFilePath.toFile());
            myWriter.write(schema);
            myWriter.close();
        } catch (java.io.IOException e) {
            throw new RuntimeException("Failed to write schema to " + schemaFilePath, e);
        }
        return schemaFilePath;
    }

    private ProtobufSchema setProtoOptions(ProtobufSchema protobufSchema, String className) {
        Descriptors.FileDescriptor originalDescriptor = protobufSchema.toDescriptor().getFile();

        String protoPackageName = protobufSchema.rawSchema().getPackageName();
        if (protoPackageName == null || protoPackageName.isEmpty()) {
            throw new IllegalArgumentException("Proto package name was null or empty in " + protobufSchema.rawSchema().toSchema());
        }

        DescriptorProtos.FileOptions newOptions = DescriptorProtos.FileOptions.newBuilder()
                .mergeFrom(originalDescriptor.getOptions())
                // Without this, the generated class will be prefixed with the package name e.g. SomePackageNameClassName
                .setJavaOuterClassname(className)
                // For deterministic compilation, we will always set java package to proto package
                .setJavaPackage(protoPackageName)
                // Don't split the generated class into multiple files
                .setJavaMultipleFiles(false)
                .build();
        DescriptorProtos.FileDescriptorProto newProto = originalDescriptor
                .toProto()
                .toBuilder()
                .setOptions(newOptions)
                .build();
        try {
            return new ProtobufSchema(Descriptors.FileDescriptor.buildFrom(newProto, originalDescriptor.getDependencies().toArray(new Descriptors.FileDescriptor[0])));
        } catch (Exception e) {
            throw new RuntimeException("Failed to set Java outer class name.", e);
        }
    }

    private String getClassNameFromProto(ProtobufSchema protobufSchema) {
        String[] classNameParts = protobufSchema.name().split("\\.");
        return classNameParts[classNameParts.length - 1];
    }

    private void copyConfluentProto(String resourceName) {
        InputStream protoFileStream = ProtoCompiler.class.getResourceAsStream(resourceName);
        if (protoFileStream == null) {
            throw new IllegalArgumentException("Could not find the proto file: " + resourceName);
        }
        BufferedReader reader = new BufferedReader(new InputStreamReader(protoFileStream, StandardCharsets.UTF_8));
        String protoFileContents = reader.lines().collect(Collectors.joining("\n"));

        String protoFileName = resourceName.substring(resourceName.lastIndexOf("/") + 1);
        Path protoFilePath = confluentProtosDir.resolve(protoFileName);
        try {
            Files.write(protoFilePath, protoFileContents.getBytes());
        } catch (Exception e) {
            throw new RuntimeException("Failed to write proto file to " + protoFilePath, e);
        }
    }

    private static Path createParentDir() {
        try {
            return Files.createTempDirectory("protoc-");
        } catch (Exception e) {
            throw new RuntimeException("Could not create temporary directory", e);
        }
    }

    private static Path createChildDir(Path parentDir, String name) {
        if (!Files.exists(parentDir)) {
            throw new IllegalArgumentException("Parent directory does not exist");
        }

        Path childPath = parentDir.resolve(name);
        if (Files.exists(childPath)) {
            return childPath;
        }

        try {
            return Files.createDirectory(parentDir.resolve(name));
        } catch (Exception e) {
            throw new RuntimeException("Could not create child directory", e);
        }
    }

    private static String generateClassSuffix() {
        return UUID.randomUUID().toString().replace("-", "");
    }

}
